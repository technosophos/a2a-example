// For AutoRouter documentation refer to https://itty.dev/itty-router/routers/autorouter
import { AutoRouter, createResponse } from "itty-router";
import { GoogleGenAI } from "@google/genai";

let gemini = new GoogleGenAI({
  apiKey: "AIzaSyDLls3dMKSIF_N9p49X8WnPjP6JZUH4r7s",
});
let router = AutoRouter();

const AGENT_CARD = {
  name: "The Digital Ethicist",
  description:
    "This agent analyzes ethical questions based on philopsophical ethics frameworks such as utilitiarism, deontology, or virtue ethics.",
  //url: `https://FIXME.aka.fermyon.app`,
  url: "http://localhost:41241/api",
  provider: {
    organization: "Technosophos",
  },
  version: "0.1.0",
  // documentationUrl
  capabilities: {
    streaming: false,
    pushNotifications: false,
    stateTransitionHistory: false,
  },
  defaultInputModes: ["text/plain"],
  defaultOutputModes: ["text/plain"],
  skill: [
    {
      id: "ethics-utilitarian",
      name: "Digitial Utilitarian",
      description:
        "Address ethical problems and dilemmas using utilitarian approaches.",
      tags: [
        "philosophy",
        "ethics",
        "reasoning",
        "morality",
        "moral philosophy",
        "utilitarianism",
        "hedonic calculus",
      ],
      examples: [
        "A doctor is performing two surgeries. On one operating table is a person who will survive if she receives a kidney transplant in the next hour. No transplant is available. On the other is a gentleman who will also certainly die, but whose kidney is functioning perfectly. The blood types of the patients are compatible. Should the surgeon remove the surgent from the second patient and transplant it into the first?",
      ],
    },
  ],
};

// Route ordering matters, the first route that matches will be used
// Any route that does not return will be treated as a middleware
// Any unmatched route will return a 404
router
  .post("/api", async (req: Request) => await taskRouter(req))
  .post(
    "/api/ethics-utilitarian",
    async (req: Request) => await taskRouter(req),
  )
  .post("/*", async (req: Request) => await taskRouter(req))
  // The A2A agent card
  .get("/.well-known/agent.json", ({}) => getAgentCard());

//@ts-ignore
addEventListener("fetch", async (event: FetchEvent) => {
  event.respondWith(router.fetch(event.request));
});

function getAgentCard(): Response {
  console.log("Agent card fetched");
  let res = new Response(JSON.stringify(AGENT_CARD));
  res.headers.set("content-type", "application/json");

  return res;
}

async function taskRouter(req: Request): Promise<Response> {
  console.log("routing task");
  let payload = JSON.parse(await req.text());
  let id = payload.id || "undefined_id";
  let params = payload.params || {};
  console.log(payload.method || "NO PAYLOAD ID");
  switch (payload.method) {
    case "tasks/sendSubscribe":
    case "tasks/send":
      console.log("Utilitarian");
      return await taskUtilitarian(id, params);
    default:
      return Promise.resolve(new Response("Not found", { status: 404 }));
  }
}

async function taskUtilitarian(id: string, params: any): Promise<Response> {
  let question = params.message.parts[0].text;
  let task = new Task();
  task.id = id;
  task.sessionId = generateSessionId();
  task.status = new TaskStatus();
  task.status.state = "completed";
  task.status.message = {
    role: "agent",
    parts: [
      {
        type: "text",
        text: await doGeminiInference(question),
      },
    ],
  };

  let envelope = {
    jsonrpc: "2.0",
    id: id,
    result: task,
  };

  let res = new Response(JSON.stringify(envelope));
  res.headers.set("content-type", "application/json");
  return res;
}

async function doGeminiInference(question: string): Promise<string> {
  let inference = await gemini.models.generateContent({
    model: "gemini-2.0-flash",
    contents: `You are a utilitarian moral philosopher. Announce which moral framework you are using, and then answer the question.

    ${question}`,
  });
  return Promise.resolve(inference.text || "Some philosophers choose silence.");
}

function generateSessionId(): string {
  return "session-1";
}

// -- INTERFACES DEFINED IN THE SPEC -- //
// https://google.github.io/A2A/specification/

class Task {
  // A unique identifier for the task. This ID is typically generated by the client
  // when initiating the task and MUST be used by the server to refer to this task.
  // It should be sufficiently unique (e.g., a UUID v4).
  id: string = "";
  // An optional, client-generated identifier used to group related tasks into a logical session.
  // Useful for maintaining context across multiple, sequential, or related tasks.
  sessionId?: string | null;
  // The current status of the task, including its lifecycle state, an optional associated message,
  // and a timestamp.
  status?: TaskStatus;
  // An array of outputs (artifacts) generated by the agent for this task.
  // This array can be populated incrementally, especially during streaming.
  // Artifacts represent the tangible results of the task.
  artifacts?: Artifact[] | null;
  // An optional array of recent messages exchanged within this task,
  // ordered chronologically (oldest first).
  // This history is included if requested by the client via the `historyLength` parameter
  // in `TaskSendParams` or `TaskQueryParams`.
  history?: Message[] | null;
  // Arbitrary key-value metadata associated with the task.
  // Keys SHOULD be strings; values can be any valid JSON type (string, number, boolean, array, object).
  // This can be used for application-specific data, tracing info, etc.
  metadata?: Record<string, any> | null;
}

class TaskStatus {
  // The current lifecycle state of the task.
  state: TaskState = "unknown";
  // An optional message associated with the current status.
  // This could be a progress update from the agent, a prompt for more input,
  // a summary of the final result, or an error message.
  message?: Message | null;
  // The date and time (UTC is STRONGLY recommended) when this status was recorded by the server.
  // Format: ISO 8601 `date-time` string (e.g., "2023-10-27T10:00:00Z").
  timestamp?: string | null;
}

type TaskState =
  | "submitted" // Task received by server, acknowledged, but processing has not yet actively started.
  | "working" // Task is actively being processed by the agent.
  | "input-required" // Agent requires additional input from the client/user to proceed. (Task is paused)
  | "completed" // Task finished successfully. (Terminal state)
  | "canceled" // Task was canceled by the client or potentially by the server. (Terminal state)
  | "failed" // Task terminated due to an error during processing. (Terminal state)
  | "unknown"; // The state of the task cannot be determined (e.g., task ID invalid or expired). (Effectively a terminal state from client's PoV for that ID)

interface Message {
  // Indicates the sender of the message:
  // "user" for messages originating from the A2A Client (acting on behalf of an end-user or system).
  // "agent" for messages originating from the A2A Server (the remote agent).
  role: "user" | "agent";
  // An array containing the content of the message, broken down into one or more parts.
  // A message MUST contain at least one part.
  // Using multiple parts allows for rich, multi-modal content (e.g., text accompanying an image).
  parts: Part[];
  // Arbitrary key-value metadata associated with the message.
  // Keys SHOULD be strings; values can be any valid JSON type.
  // Useful for timestamps, source identifiers, language codes, etc.
  metadata?: Record<string, any> | null;
}

export type Part = TextPart | FilePart | DataPart;

interface TextPart {
  type: "text"; // Discriminator
  text: string; // The actual textual content.
  metadata?: Record<string, any> | null; // Optional metadata (e.g., language, formatting hints if any)
}

interface FilePart {
  type: "file"; // Discriminator
  file: FileContent; // Contains the file details and data (or reference).
  metadata?: Record<string, any> | null; // Optional metadata (e.g., purpose of the file)
}

interface DataPart {
  type: "data"; // Discriminator
  // The structured JSON data payload. This can be any valid JSON object or array.
  // The schema of this data is application-defined and may be implicitly understood
  // by the interacting agents or explicitly described (e.g., via a JSON Schema reference
  // in the `metadata` or associated `AgentSkill`).
  data: Record<string, any> | any[];
  metadata?: Record<string, any> | null; // Optional metadata (e.g., schema URL, version)
}

interface FileContent {
  // The original filename, if known (e.g., "document.pdf", "avatar.png").
  name?: string | null;
  // The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
  // of the file (e.g., "application/pdf", "image/png"). Strongly recommended for proper handling.
  mimeType?: string | null;
  // Base64 encoded string of the raw file content.
  // Use this for embedding small to medium-sized files directly.
  bytes?: string | null; // Base64 string
  // A URI (absolute URL is STRONGLY recommended) pointing to the file content.
  // Accessibility of this URI depends on the context (e.g., public URL, pre-signed URL, internal URL).
  // The client and server must have a way to resolve and access this URI if used.
  uri?: string | null;

  // Constraint: If file content is being transmitted, exactly one of `bytes` or `uri` MUST be non-null.
  // Both MAY be `null` or absent if the `FilePart` is merely representing a file reference
  // without transmitting its content in the current message (e.g., referring to a previously uploaded file).
}

interface Artifact {
  // A descriptive name for the artifact (e.g., "Quarterly Sales Report.pdf", "Generated Logo Design", "analysis_results.json").
  // This name might be used by the client for display or identification.
  name?: string | null;
  // A human-readable description of the artifact. [CommonMark](https://commonmark.org/) MAY be used.
  description?: string | null;
  // An array containing the content of the artifact, broken down into one or more parts.
  // An artifact MUST contain at least one part.
  // Using multiple parts allows for complex artifacts (e.g., a report with embedded images or data tables).
  parts: Part[];
  // A non-negative integer index for ordering artifacts or identifying artifact chunks during streaming.
  // Multiple artifacts (or artifact updates) can share the same index if they represent parts of the same logical output
  // that are being streamed or delivered separately.
  // Default: 0 if omitted.
  index?: number;
  // Used with streaming (`TaskArtifactUpdateEvent`):
  // If `true`, indicates this update's `parts` should be appended to the content of the artifact
  // currently identified by the same `index` value. This is useful for streaming textual data or
  // appending elements to a list in a `DataPart`.
  // If `false` or `null` (or omitted), this update replaces the artifact content at the given `index`.
  // This field is typically `false` for the first chunk of a streamed artifact.
  append?: boolean | null;
  // Used with streaming (`TaskArtifactUpdateEvent`):
  // If `true`, indicates this is the final update/chunk for the artifact at this `index`.
  // Signals the end of a streamed file or data structure.
  lastChunk?: boolean | null;
  // Arbitrary key-value metadata associated with the artifact.
  // Keys SHOULD be strings; values can be any valid JSON type.
  // Useful for creation timestamps, versioning info, checksums, etc.
  metadata?: Record<string, any> | null;
}
